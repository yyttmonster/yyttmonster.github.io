<p>借鉴于《Python源码剖析 陈儒》及[python/cpython](<a href="https://github.com/python/cpython/blob/v3.7.0/Objects/unicodeobject.c">https://github.com/python/cpython/blob/v3.7.0/Objects/unicodeobject.c</a> v3.70</p>

<p>string 是一个常见的数据类型，它与<code class="language-plaintext highlighter-rouge">bytes</code>对象密切相关。python3中使用<code class="language-plaintext highlighter-rouge">text</code>和<code class="language-plaintext highlighter-rouge">binary data</code>来替代unicode字符串和普通字符串，分别对应<code class="language-plaintext highlighter-rouge">str(PyUnicodeObject)</code>和<code class="language-plaintext highlighter-rouge">bytes(PyBytesObject)</code>，程序中以<code class="language-plaintext highlighter-rouge">''</code>或<code class="language-plaintext highlighter-rouge">""</code>定义的字符串对应的都是<code class="language-plaintext highlighter-rouge">str</code>，要定义<code class="language-plaintext highlighter-rouge">bytes</code>必须以<code class="language-plaintext highlighter-rouge">b''</code>的形式。<code class="language-plaintext highlighter-rouge">str</code>可以通过<code class="language-plaintext highlighter-rouge">encode()</code>转为<code class="language-plaintext highlighter-rouge">bytes</code>，而<code class="language-plaintext highlighter-rouge">bytes</code>也可以通过<code class="language-plaintext highlighter-rouge">decode</code>转为<code class="language-plaintext highlighter-rouge">str</code>。</p>
<h2 id="字符编码">字符编码</h2>

<p>借鉴于<a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html">字符编码笔记：ASCII，Unicode 和 UTF-8 阮一峰</a></p>

<p>ASCII (American Standard Code for Information Interchange: 美国信息交换标准代码）仅规定了一个字节上二进制与字符的对应关系，即128个字符的编码。但是世界上语言字符很多，需要一种独一无二的能包含所有字符的编码，Unicode应运而生，但作为一个字符集，Unicode未规定存储方式，因此无法区分unicode与ascll码，无法知道是一位Unicode码还是多位ascall码，导致了多种存储方式，并且英文字母最常用且一个字节即可，若统一大小，将会产生大量的冗余。</p>

<p><strong>UTF-8作为一种Unicode实现方式之一</strong>，使用变长编码方式很好的解决了以上问题。</p>

<ol>
  <li>对于单字节的符号，字节的第一位设为<code class="language-plaintext highlighter-rouge">0</code>，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的；</li>
  <li>对于<code class="language-plaintext highlighter-rouge">n</code>字节的符号（<code class="language-plaintext highlighter-rouge">1&lt;n&lt;=4</code>），第一个字节的前<code class="language-plaintext highlighter-rouge">n</code>位都设为<code class="language-plaintext highlighter-rouge">1</code>，第<code class="language-plaintext highlighter-rouge">n + 1</code>位设为<code class="language-plaintext highlighter-rouge">0</code>，后面字节的前两位一律设为<code class="language-plaintext highlighter-rouge">10</code>。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。</li>
</ol>

<p>| unicode编码           | utf-8编码                           |
| ——————— | ———————————– |
| 0000 0000 - 0000 007F | 0XXXXXXX                            |
| 0000 0080 - 0000 07FF | 110XXXXX 10XXXXXX                   |
| 0000 0800 - 0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx          |
| 0001 0000 - 0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx |
例如:unicode  4E25(100111000100101)  – utf-8   E4B8A5(11100100 10111000 10100101)</p>

<h2 id="binary-data">Binary Data</h2>

<h3 id="pybytesobject">PyBytesObject</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// include/bytesobject.h  13-42</span>
<span class="cp">#ifdef COUNT_ALLOCS
</span><span class="n">Py_ssize_t</span> <span class="n">null_strings</span><span class="p">,</span> <span class="n">one_strings</span><span class="p">;</span>
<span class="cp">#endif
</span><span class="k">static</span> <span class="n">PyBytesObject</span> <span class="o">*</span><span class="n">characters</span><span class="p">[</span><span class="n">UCHAR_MAX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span> <span class="err">\\静态字符缓冲池</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">PyObject_VAR_HEAD</span>
    <span class="n">Py_hash_t</span> <span class="n">ob_shash</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">ob_sval</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="cm">/* Invariants:
     * ob_sval contains space for 'ob_size+1' elements.
     * ob_sval[ob_size] == 0.
     * ob_shash is the hash of the string or -1 if not computed yet.
     */</span>
<span class="p">}</span> <span class="n">PyBytesObject</span><span class="p">;</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">PyBytesObject</code>代表一个字符串，可以看到它是一个变长对象，<code class="language-plaintext highlighter-rouge">ob_shash</code>是一个字符指针，指向该字符串对象实际的存储地址，这段地址的长度由变长对象中的<code class="language-plaintext highlighter-rouge">ob_size</code>维护。</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">string</span> <span class="o">=</span> <span class="sh">'</span><span class="s">ab</span><span class="se">\0</span><span class="s">cd</span><span class="sh">'</span>  
<span class="n">a</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\0</span><span class="sh">'</span>  
<span class="nf">print</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>  
<span class="nf">print</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">string</span><span class="p">))</span>  
<span class="nf">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>


<span class="n">abcd</span>
<span class="mi">5</span>
<span class="sa">b</span><span class="sh">'</span><span class="se">\x00</span><span class="sh">'</span>   <span class="c1"># ‘\0’是一个“空字符”常量，它的ASCII码值为0
</span></code></pre></div></div>
<p>与C中一样，内部维护的字符串必须以<code class="language-plaintext highlighter-rouge">'\0'</code>结尾，但其实际长度是由<code class="language-plaintext highlighter-rouge">ob_size</code>维护，因此字符串中间是可以出现<code class="language-plaintext highlighter-rouge">'\0'</code>的，内存中实际长度为<code class="language-plaintext highlighter-rouge">ob_size+1</code>，满足<code class="language-plaintext highlighter-rouge">ob_sval[ob_size] == '\0'</code>。<code class="language-plaintext highlighter-rouge">ob_shash</code>用于缓存该对象的<code class="language-plaintext highlighter-rouge">hash</code>值，避免每次都重新计算该字符串对象的<code class="language-plaintext highlighter-rouge">hash</code>值，初始值为-1，该值可用于<code class="language-plaintext highlighter-rouge">intern</code>机制（虽然<code class="language-plaintext highlighter-rouge">intern</code>机制只针对<code class="language-plaintext highlighter-rouge">PyUnicodeObject</code>）。</p>

<h3 id="bytes字符串的创建">bytes字符串的创建</h3>

<p>创建字符串对象有两种方式，<code class="language-plaintext highlighter-rouge">PyBytes_FromString</code>和<code class="language-plaintext highlighter-rouge">PyBytes_FromStringAndSize</code>。</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">//</span> <span class="n">Objects</span><span class="o">/</span><span class="n">bytesobject</span><span class="p">.</span><span class="n">c</span> <span class="mi">135</span><span class="o">-</span><span class="mi">178</span>
<span class="n">PyObject</span> <span class="o">*</span> <span class="nc">PyBytes_FromString</span><span class="p">(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="nb">str</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">size_t</span> <span class="n">size</span><span class="p">;</span>
    <span class="n">PyBytesObject</span> <span class="o">*</span><span class="n">op</span><span class="p">;</span>
    <span class="nf">assert</span><span class="p">(</span><span class="nb">str</span> <span class="o">!=</span> <span class="n">NULL</span><span class="p">);</span>
    <span class="n">size</span> <span class="o">=</span> <span class="nf">strlen</span><span class="p">(</span><span class="nb">str</span><span class="p">);</span>
    
    <span class="o">//</span><span class="n">判断字符串长度</span>
    <span class="nf">if </span><span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">PY_SSIZE_T_MAX</span> <span class="o">-</span> <span class="n">PyBytesObject_SIZE</span><span class="p">)</span> <span class="p">{</span>
        <span class="nc">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_OverflowError</span><span class="p">,</span><span class="sh">"</span><span class="s">byte string is too long</span><span class="sh">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="o">//</span><span class="n">null</span> <span class="n">string及短字符intern机制共享</span><span class="err">（</span><span class="n">这两句判断语句表示当前字符串已存在时</span><span class="err">）</span>
    <span class="nf">if </span><span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">op</span> <span class="o">=</span> <span class="n">nullstring</span><span class="p">)</span> <span class="o">!=</span> <span class="n">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">#ifdef COUNT_ALLOCS
</span>            <span class="n">null_strings</span><span class="o">++</span><span class="p">;</span>
        <span class="c1">#endif
</span>            <span class="nc">Py_INCREF</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
        <span class="nf">return </span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="n">op</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nf">if </span><span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">op</span> <span class="o">=</span> <span class="n">characters</span><span class="p">[</span><span class="o">*</span><span class="nb">str</span> <span class="o">&amp;</span> <span class="n">UCHAR_MAX</span><span class="p">])</span> <span class="o">!=</span> <span class="n">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">#ifdef COUNT_ALLOCS
</span>            <span class="n">one_strings</span><span class="o">++</span><span class="p">;</span>
        <span class="c1">#endif
</span>            <span class="nc">Py_INCREF</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
        <span class="nf">return </span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="n">op</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="o">//</span><span class="n">内存申请</span>
    <span class="o">/*</span> <span class="n">Inline</span> <span class="n">PyObject_NewVar</span> <span class="o">*/</span>
    <span class="n">op</span> <span class="o">=</span> <span class="p">(</span><span class="n">PyBytesObject</span> <span class="o">*</span><span class="p">)</span><span class="nc">PyObject_MALLOC</span><span class="p">(</span><span class="n">PyBytesObject_SIZE</span> <span class="o">+</span> <span class="n">size</span><span class="p">);</span>
    <span class="nf">if </span><span class="p">(</span><span class="n">op</span> <span class="o">==</span> <span class="n">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="nc">PyErr_NoMemory</span><span class="p">();</span>
    <span class="p">(</span><span class="n">void</span><span class="p">)</span><span class="nc">PyObject_INIT_VAR</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">PyBytes_Type</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
    <span class="o">//</span> <span class="n">hash值默认为</span><span class="o">-</span><span class="mi">1</span>
    <span class="n">op</span><span class="o">-&gt;</span><span class="n">ob_shash</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="nf">memcpy</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">ob_sval</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">size</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>

    <span class="o">/*</span> <span class="n">share</span> <span class="n">short</span> <span class="n">strings</span> <span class="o">*/</span>
    <span class="nf">if </span><span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">nullstring</span> <span class="o">=</span> <span class="n">op</span><span class="p">;</span>
        <span class="nc">Py_INCREF</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="nf">if </span><span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">//</span><span class="n">UCHAR_MAX</span> <span class="n">win32默认为255</span><span class="err">；</span><span class="n">characters为字符缓冲池</span>
        <span class="n">characters</span><span class="p">[</span><span class="o">*</span><span class="nb">str</span> <span class="o">&amp;</span> <span class="n">UCHAR_MAX</span><span class="p">]</span> <span class="o">=</span> <span class="n">op</span><span class="p">;</span> 
        <span class="nc">Py_INCREF</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>     <span class="o">//</span> <span class="n">计数宏</span><span class="err">，</span><span class="n">引用计数加一</span>
    <span class="p">}</span>
    <span class="nf">return </span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span> <span class="n">op</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">PyObject</span> <span class="o">*</span> <span class="nc">PyBytes_FromStringAndSize</span><span class="p">(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="nb">str</span><span class="p">,</span> <span class="n">Py_ssize_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{......}</span>

</code></pre></div></div>
<p>传给<code class="language-plaintext highlighter-rouge">PyString_FromString</code>的参数必须是一个指向以<code class="language-plaintext highlighter-rouge">\0</code>结尾的字符串的指针（the parameter ‘str’ points to a null-terminated string containing exactly ‘size’ bytes.），<code class="language-plaintext highlighter-rouge">PyString_FromString</code>通过传入的<code class="language-plaintext highlighter-rouge">size</code>参数就知道需要拷贝的字符长度，因而参数不需要一定是以<code class="language-plaintext highlighter-rouge">\0</code>结尾的字符数组的指针（the parameter ‘str’ is either NULL or else points to a string containing at least ‘size’ bytes）。创建时，会判断长度，并使用对象共享。</p>

<h2 id="text">Text</h2>

<h3 id="pyunicodeobject">PyUnicodeObject</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Include/cpython/unicodeobject.h</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="cm">/* There are 4 forms of Unicode strings:
	- compact ascii:
	* structure = PyASCIIObject
	* test: PyUnicode_IS_COMPACT_ASCII(op)
	* kind = PyUnicode_1BYTE_KIND
	* compact = 1
	* ascii = 1
	* ready = 1
	* (length is the length of the utf8 and wstr strings)
	* (data starts just after the structure)
	* (since ASCII is decoded from UTF-8, the utf8 string are the data)
	- compact:
	* structure = PyCompactUnicodeObject
	* test: PyUnicode_IS_COMPACT(op) &amp;&amp; !PyUnicode_IS_ASCII(op)
	* kind = PyUnicode_1BYTE_KIND, PyUnicode_2BYTE_KIND or
	PyUnicode_4BYTE_KIND
	* compact = 1
	* ready = 1
	* ascii = 0
	* utf8 is not shared with data
	* utf8_length = 0 if utf8 is NULL
	* wstr is shared with data and wstr_length=length
	if kind=PyUnicode_2BYTE_KIND and sizeof(wchar_t)=2
	or if kind=PyUnicode_4BYTE_KIND and sizeof(wchar_t)=4
	* wstr_length = 0 if wstr is NULL
	* (data starts just after the structure)
	- legacy string, not ready:
	* structure = PyUnicodeObject
	* test: kind == PyUnicode_WCHAR_KIND
	* length = 0 (use wstr_length)
	* hash = -1
	* kind = PyUnicode_WCHAR_KIND
	* compact = 0
	* ascii = 0
	* ready = 0
	* interned = SSTATE_NOT_INTERNED
	* wstr is not NULL
	* data.any is NULL
	* utf8 is NULL
	* utf8_length = 0
	- legacy string, ready:
	* structure = PyUnicodeObject structure
	* test: !PyUnicode_IS_COMPACT(op) &amp;&amp; kind != PyUnicode_WCHAR_KIND
	* kind = PyUnicode_1BYTE_KIND, PyUnicode_2BYTE_KIND or
	PyUnicode_4BYTE_KIND
	* compact = 0
	* ready = 1
	* data.any is not NULL
	* utf8 is shared and utf8_length = length with data.any if ascii = 1
	* utf8_length = 0 if utf8 is NULL
	* wstr is shared with data.any and wstr_length = length
	if kind=PyUnicode_2BYTE_KIND and sizeof(wchar_t)=2
	or if kind=PyUnicode_4BYTE_KIND and sizeof(wchar_4)=4
	* wstr_length = 0 if wstr is NULL
	Compact strings use only one memory block (structure + characters),
	whereas legacy strings use one block for the structure and one block
	for characters.
	Legacy strings are created by PyUnicode_FromUnicode() and
	PyUnicode_FromStringAndSize(NULL, size) functions. They become ready
	when PyUnicode_READY() is called.
	See also _PyUnicode_CheckConsistency().
	*/</span>

	<span class="n">PyObject_HEAD</span>
	<span class="n">Py_ssize_t</span> <span class="n">length</span><span class="p">;</span> <span class="cm">/* Number of code points in the string */</span>
	<span class="n">Py_hash_t</span> <span class="n">hash</span><span class="p">;</span> <span class="cm">/* Hash value; -1 if not set */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="cm">/*
		SSTATE_NOT_INTERNED (0)
		SSTATE_INTERNED_MORTAL (1)
		SSTATE_INTERNED_IMMORTAL (2)
		If interned != SSTATE_NOT_INTERNED, the two references from the
		dictionary to this object are *not* counted in ob_refcnt.
		*/</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">interned</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
		<span class="cm">/* Character size:
		- PyUnicode_WCHAR_KIND (0):
		* character type = wchar_t (16 or 32 bits, depending on the
		platform)
		- PyUnicode_1BYTE_KIND (1):
		* character type = Py_UCS1 (8 bits, unsigned)
		* all characters are in the range U+0000-U+00FF (latin1)
		* if ascii is set, all characters are in the range U+0000-U+007F
		(ASCII), otherwise at least one character is in the range
		U+0080-U+00FF
		- PyUnicode_2BYTE_KIND (2):
		* character type = Py_UCS2 (16 bits, unsigned)
		* all characters are in the range U+0000-U+FFFF (BMP)
		* at least one character is in the range U+0100-U+FFFF
		- PyUnicode_4BYTE_KIND (4):
		* character type = Py_UCS4 (32 bits, unsigned)
		* all characters are in the range U+0000-U+10FFFF
		* at least one character is in the range U+10000-U+10FFFF
		*/</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">kind</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
		<span class="cm">/* Compact is with respect to the allocation scheme. Compact unicode
		objects only require one memory block while non-compact objects use
		one block for the PyUnicodeObject struct and another for its data
		buffer. */</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">compact</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* The string only contains characters in the range U+0000-U+007F (ASCII)
		and the kind is PyUnicode_1BYTE_KIND. If ascii is set and compact is
		set, use the PyASCIIObject structure. */</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ascii</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* The ready flag indicates whether the object layout is initialized
		completely. This means that this is either a compact object, or
		the data pointer is filled out. The bit is redundant, and helps
		to minimize the test in PyUnicode_IS_READY(). */</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ready</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* Padding to ensure that PyUnicode_DATA() is always aligned to
		4 bytes (see issue #19537 on m68k). */</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">:</span><span class="mi">24</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">state</span><span class="p">;</span>
    <span class="kt">wchar_t</span> <span class="o">*</span><span class="n">wstr</span><span class="p">;</span> <span class="cm">/* wchar_t representation (null-terminated) */</span>
<span class="p">}</span> <span class="n">PyASCIIObject</span><span class="p">;</span>
<span class="cm">/* Non-ASCII strings allocated through PyUnicode_New use the
PyCompactUnicodeObject structure. state.compact is set, and the data
immediately follow the structure. */</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">PyASCIIObject</span> <span class="n">_base</span><span class="p">;</span>
    <span class="n">Py_ssize_t</span> <span class="n">utf8_length</span><span class="p">;</span> <span class="cm">/* Number of bytes in utf8, excluding the
    * terminating \0. */</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">utf8</span><span class="p">;</span> <span class="cm">/* UTF-8 representation (null-terminated) */</span>
    <span class="n">Py_ssize_t</span> <span class="n">wstr_length</span><span class="p">;</span> <span class="cm">/* Number of code points in wstr, possible
    * surrogates count as two code points. */</span>
<span class="p">}</span> <span class="n">PyCompactUnicodeObject</span><span class="p">;</span>

<span class="cm">/* Strings allocated through PyUnicode_FromUnicode(NULL, len) use the
PyUnicodeObject structure. The actual string data is initially in the wstr
block, and copied into the data block using _PyUnicode_Ready. */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">PyCompactUnicodeObject</span> <span class="n">_base</span><span class="p">;</span>
    <span class="k">union</span> <span class="p">{</span>
        <span class="kt">void</span> <span class="o">*</span><span class="n">any</span><span class="p">;</span>
        <span class="n">Py_UCS1</span> <span class="o">*</span><span class="n">latin1</span><span class="p">;</span>
        <span class="n">Py_UCS2</span> <span class="o">*</span><span class="n">ucs2</span><span class="p">;</span>
        <span class="n">Py_UCS4</span> <span class="o">*</span><span class="n">ucs4</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">data</span><span class="p">;</span> <span class="cm">/* Canonical, smallest-form Unicode buffer */</span>
<span class="p">}</span> <span class="n">PyUnicodeObject</span><span class="p">;</span>
</code></pre></div></div>
<p>Unicode字符串共四种形式:</p>
<ul>
  <li>compact ascii</li>
  <li>-compact</li>
  <li>legacy string, not ready</li>
  <li>legacy string, ready</li>
</ul>

<p>当一个字符串的大小和最大字符都是确定的，它就是<code class="language-plaintext highlighter-rouge">compact unicode objects</code>，它仅使用一个连续的内存块来存储内容，即字符内容是紧跟在结构体后面的，而对于非<code class="language-plaintext highlighter-rouge">compact</code>字符串，结构体与字符是存在两个不连续内存块中的。若字符串中最大字符小于128，就使用<code class="language-plaintext highlighter-rouge">PyASCIIObject</code>结构体以及UTF-8数据，数据长度与<code class="language-plaintext highlighter-rouge">wstr</code>长度相同。对于<code class="language-plaintext highlighter-rouge">non-ASCLL</code>字符串，将使用<code class="language-plaintext highlighter-rouge">PyCompactObject</code>。</p>

<p>若字符串最大字符在创建时没有给定，它就是<code class="language-plaintext highlighter-rouge">legacy </code>对象，使用<code class="language-plaintext highlighter-rouge">PyUnicodeObject</code>结构体，结构体与字符所在内存块不连续，<code class="language-plaintext highlighter-rouge">wstr</code>中仅是一个指针，当<code class="language-plaintext highlighter-rouge">PyUnicode_READY</code>被调用时，数据指针才被分配空间。</p>

<h2 id="共享对象与intern机制">共享对象与INTERN机制</h2>

<p>借鉴于<a href="https://medium.com/@bdov_/https-medium-com-bdov-python-this-is-an-object-that-is-an-object-everything-is-an-object-fff50429cd4b">Python Objects</a> part1 - 4</p>

<p>程序中难免会存在许多相同值的对象实例，例如整数等，如果为相同的值都重新分配空间，那是很浪费的，并且频繁的进行空间申请与释放操作，既耗时又会产生大量内存碎片，因此python使用共享对象或<code class="language-plaintext highlighter-rouge">str</code>的intern机制来进行优化。其思想都是将对象保存至内存，当再次创建对象时，若已存在相同值的对象，则返回该对象的指针，而不必分配空间，再创建一个实例。</p>

<h3 id="可变对象与不可变对象">可变对象与不可变对象</h3>

<p>在python中，如果对象是<code class="language-plaintext highlighter-rouge">immutable</code>的（等效于unchangeable），会在内存中存储一个实例，这个实例的值与它的<code class="language-plaintext highlighter-rouge">id</code>是对应的（值改变，那么id也随之改变），在创建一个<code class="language-plaintext highlighter-rouge">immutable</code>对象时，首先会检查内存中是否已经存在这样一个实例，若存在，直接返回该实例的指针，而对于<code class="language-plaintext highlighter-rouge">mutable</code>对象，每次都会直接实例化一个新的对象。
<img src="/img/string_object_1.png" alt="avator" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>  \\ <span class="nb">list</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">mutable</span> <span class="nb">object</span>
<span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>  
<span class="n">c</span> <span class="o">=</span> <span class="sh">'</span><span class="s">a</span><span class="sh">'</span>       \\ <span class="nb">str</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">immutable</span> <span class="nb">object</span>
<span class="n">d</span> <span class="o">=</span> <span class="sh">'</span><span class="s">a</span><span class="sh">'</span>  
<span class="nf">print</span><span class="p">(</span><span class="nf">id</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>  
<span class="nf">print</span><span class="p">(</span><span class="nf">id</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>  
<span class="nf">print</span><span class="p">(</span><span class="nf">id</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>  
<span class="nf">print</span><span class="p">(</span><span class="nf">id</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>

<span class="mi">2990536497352</span>
<span class="mi">2990536497416</span>
<span class="mi">2990250300504</span>
<span class="mi">2990250300504</span>
</code></pre></div></div>
<p>对象的可变性直接影响程序中的许多操作，例如下面代码中的赋值操作：</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">a</span>
<span class="n">b</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="n">aa</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">bb</span> <span class="o">=</span> <span class="n">aa</span>
<span class="n">bb</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="sh">'</span><span class="s"> VS </span><span class="sh">'</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">aa</span><span class="p">,</span> <span class="sh">'</span><span class="s"> VS </span><span class="sh">'</span><span class="p">,</span> <span class="n">bb</span><span class="p">)</span>

<span class="mi">1</span>  <span class="n">VS</span>  <span class="mi">2</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>  <span class="n">VS</span>  <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
</code></pre></div></div>
<p>观察上述代码，同样是直接赋值，两个变量都是同一对象的引用，为何当值改变后，一个没有影响另一个的值，另一个却改变了？这正是可变性在发挥作用。对于<code class="language-plaintext highlighter-rouge">immutable</code>对象，值和<code class="language-plaintext highlighter-rouge">id</code>已经绑定，内存大小已经固定，是无法进行修改的，修改值之后，实际上是新建了一个对象，然后由变量指向它，也就是说<code class="language-plaintext highlighter-rouge">b += 1</code>这一句，新建了一个对象<code class="language-plaintext highlighter-rouge">2</code>，由<code class="language-plaintext highlighter-rouge">b</code>指向它。对于可变对象，对象本身不变，只是值在修改。
<em>注：python赋值分为直接赋值（对象的引用 - <code class="language-plaintext highlighter-rouge">=</code>）、浅拷贝（创建新对象，但包含的是原对象中包含项的引用，即拷贝父对象，但不拷贝内部子对象 - 切片；工厂函数list()等；<code class="language-plaintext highlighter-rouge">copy.copy()</code>）和深度拷贝（拷贝父对象及子对象 - <code class="language-plaintext highlighter-rouge">copy.deepcopy()</code>）三种。</em></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">copy</span>  
  
<span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="p">[</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">b</span><span class="sh">'</span><span class="p">]]</span>  <span class="c1"># 原始对象  
</span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span>  <span class="c1"># 赋值，传对象的引用  
</span><span class="n">c</span> <span class="o">=</span> <span class="n">copy</span><span class="p">.</span><span class="nf">copy</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  <span class="c1"># 浅拷贝  
</span><span class="n">d</span> <span class="o">=</span> <span class="n">copy</span><span class="p">.</span><span class="nf">deepcopy</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  <span class="c1"># 深拷贝  
</span>  
<span class="n">a</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>  <span class="c1"># 修改对象a  
</span><span class="n">a</span><span class="p">[</span><span class="mi">4</span><span class="p">].</span><span class="nf">append</span><span class="p">(</span><span class="sh">'</span><span class="s">c</span><span class="sh">'</span><span class="p">)</span>  <span class="c1"># 修改对象a中的['a', 'b']数组对象  
</span>  
<span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">a = </span><span class="sh">'</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>  
<span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">b = </span><span class="sh">'</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>  
<span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">c = </span><span class="sh">'</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>  
<span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">d = </span><span class="sh">'</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>


<span class="n">a</span> <span class="o">=</span>  <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="p">[</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">b</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">c</span><span class="sh">'</span><span class="p">],</span> <span class="mi">5</span><span class="p">]</span>
<span class="n">b</span> <span class="o">=</span>  <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="p">[</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">b</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">c</span><span class="sh">'</span><span class="p">],</span> <span class="mi">5</span><span class="p">]</span>
<span class="n">c</span> <span class="o">=</span>  <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="p">[</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">b</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">c</span><span class="sh">'</span><span class="p">]]</span>
<span class="n">d</span> <span class="o">=</span>  <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="p">[</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">b</span><span class="sh">'</span><span class="p">]]</span>
</code></pre></div></div>

<p><img src="/img/string_object_2.png" alt="avator" /></p>

<h3 id="共享对象">共享对象</h3>

<p>共享机制实际上就是存在一个大小固定的缓冲池，将共享对象放入缓冲池中。
实际程序中，对于每一个<code class="language-plaintext highlighter-rouge">immutable</code>对象实例，我们难道都需要将其保存在内存中，等待下一次实例化时，返回引用吗？显然是不实际的。因此，对于每一类对象，其实都是存在一定限制的，在满足相应限制条件时，才会使用共享机制。
1） int
实际编程中，数值较小的数，可能会被频繁使用，刚好<code class="language-plaintext highlighter-rouge">int</code>又是<code class="language-plaintext highlighter-rouge">immutable</code>的，因此我们可以共享这些数值，而不必频繁的申请空间创建实例。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">\\</span> <span class="n">Objects</span><span class="o">/</span><span class="n">longobject</span><span class="p">.</span><span class="n">c</span>
<span class="cp">#ifndef NSMALLPOSINTS
#define NSMALLPOSINTS 257
#endif
#ifndef NSMALLNEGINTS
#define NSMALLNEGINTS 5
#endif
</span></code></pre></div></div>
<p>python中对<strong>小整数对象</strong>使用对象池，默认范围为[-5,257)，这些小整数缓存在内存中。</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">test</span><span class="p">():</span>  
    <span class="n">aaa</span> <span class="o">=</span> <span class="mi">255</span>  \\<span class="n">aaa与a</span><span class="err">、</span><span class="n">aa不在同一代码块中</span>
  <span class="nf">print</span><span class="p">(</span><span class="nf">id</span><span class="p">(</span><span class="n">aaa</span><span class="p">))</span>  

<span class="n">a</span> <span class="o">=</span> <span class="mi">255</span>  
<span class="n">aa</span> <span class="o">=</span> <span class="mi">255</span>  
<span class="nf">print</span><span class="p">(</span><span class="nf">id</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>  
<span class="nf">print</span><span class="p">(</span><span class="nf">id</span><span class="p">(</span><span class="n">aa</span><span class="p">))</span>  
<span class="nf">test</span><span class="p">()</span>


<span class="mi">1680740080</span>
<span class="mi">1680740080</span>
<span class="mi">1680740080</span>
</code></pre></div></div>
<p>但是<strong>大整数</strong>在实际程序中也可能频繁使用，因此运行环境提供一块内存空间共大整数轮流使用，在每一个程序块中都存在这么一块内存，相同代码块中的整数共享引用。（需要注意的是python无块级作用域 – LEGB）</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">test</span><span class="p">():</span>  
    <span class="n">aaa</span> <span class="o">=</span> <span class="mi">400</span>  
    <span class="n">aaaa</span> <span class="o">=</span> <span class="mi">400</span>  
    <span class="nf">print</span><span class="p">(</span><span class="nf">id</span><span class="p">(</span><span class="n">aaa</span><span class="p">))</span>  
    <span class="nf">print</span><span class="p">(</span><span class="nf">id</span><span class="p">(</span><span class="n">aaaa</span><span class="p">))</span>  

<span class="k">def</span> <span class="nf">test2</span><span class="p">():</span>  
    <span class="n">aaa</span> <span class="o">=</span> <span class="mi">400</span>  
    <span class="n">aaaa</span> <span class="o">=</span> <span class="mi">400</span>  
    <span class="nf">print</span><span class="p">(</span><span class="nf">id</span><span class="p">(</span><span class="n">aaa</span><span class="p">))</span>  
    <span class="nf">print</span><span class="p">(</span><span class="nf">id</span><span class="p">(</span><span class="n">aaaa</span><span class="p">))</span>  

<span class="n">a</span> <span class="o">=</span> <span class="mi">400</span>  
<span class="n">aa</span> <span class="o">=</span> <span class="mi">400</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">id</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>  
<span class="nf">print</span><span class="p">(</span><span class="nf">id</span><span class="p">(</span><span class="n">aa</span><span class="p">))</span>  
<span class="nf">test</span><span class="p">()</span>  
<span class="nf">test2</span><span class="p">()</span>


<span class="mi">1452189412592</span>
<span class="mi">1452189412592</span>
<span class="mi">1452189412112</span>
<span class="mi">1452189412112</span>
<span class="mi">1452189412720</span>
<span class="mi">1452189412720</span>
</code></pre></div></div>
<p>2） tuple
<code class="language-plaintext highlighter-rouge">tuple</code>是不可变对象中特殊的一员，他虽然是不可变对象，但实际上却是可能改变的（元素是可变对象），因此<strong>每次创建元组时，它会直接像可变对象一样直接新建一个对象</strong>。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  \\ <span class="n">although</span> <span class="nb">tuple</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">mutable</span> <span class="nb">object</span>
<span class="n">aa</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  
<span class="nf">print</span><span class="p">(</span><span class="nf">id</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>  
<span class="nf">print</span><span class="p">(</span><span class="nf">id</span><span class="p">(</span><span class="n">aa</span><span class="p">))</span>

<span class="mi">1308309505096</span>
<span class="mi">1308309505160</span>
</code></pre></div></div>
<p>但是值得注意的是，对于空元组，它是同一个对象。</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">=</span> <span class="p">()</span> 
<span class="n">aa</span> <span class="o">=</span> <span class="p">()</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">id</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">id</span><span class="p">(</span><span class="n">aa</span><span class="p">))</span>

<span class="mi">2379734057032</span>
<span class="mi">2379734057032</span>
</code></pre></div></div>
<p>3） bytes
bytes对象中依旧使用了对象共享，它的的实现依靠一个字符缓冲池<code class="language-plaintext highlighter-rouge">characters</code>，大小为<code class="language-plaintext highlighter-rouge">UCHAR_MAX</code>，win32下默认为255。值得注意的是，<strong>字符缓冲池是以静态变量方式存在的，它是一个字典结构。</strong></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifdef COUNT_ALLOCS
</span><span class="n">Py_ssize_t</span> <span class="n">null_strings</span><span class="p">,</span> <span class="n">one_strings</span><span class="p">;</span>
<span class="cp">#endif
</span><span class="k">static</span> <span class="n">PyBytesObject</span> <span class="o">*</span><span class="n">characters</span><span class="p">[</span><span class="n">UCHAR_MAX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span> <span class="err">\\静态缓冲池</span>

<span class="n">PyObject</span> <span class="o">*</span> <span class="nf">PyBytes_FromString</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">......</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">nullstring</span> <span class="o">=</span> <span class="n">op</span><span class="p">;</span>
        <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">characters</span><span class="p">[</span><span class="o">*</span><span class="n">str</span> <span class="o">&amp;</span> <span class="n">UCHAR_MAX</span><span class="p">]</span> <span class="o">=</span> <span class="n">op</span><span class="p">;</span>
        <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<h3 id="intern机制">intern机制</h3>

<p><strong>字符串中的<code class="language-plaintext highlighter-rouge">intern</code>机制本质上相当于共享对象，它只用于<code class="language-plaintext highlighter-rouge">PyUnicodeObject</code></strong>，字符串创建后可以通过<code class="language-plaintext highlighter-rouge">intern</code>机制在内存中保存该对象，以后再次使用只需要返回一个指针。</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//Objects/unicodeobject.c</span>
<span class="kt">void</span> <span class="nf">PyUnicode_InternInPlace</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">**</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>
    <span class="c1">// 类型检查</span>
<span class="cp">#ifdef Py_DEBUG
</span>    <span class="n">assert</span><span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">_PyUnicode_CHECK</span><span class="p">(</span><span class="n">s</span><span class="p">));</span>
<span class="cp">#else
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="o">!</span><span class="n">PyUnicode_Check</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
        <span class="k">return</span><span class="p">;</span>
<span class="cp">#endif
</span>
    <span class="cm">/* If it's a subclass, we don't really know what putting it in the interned dict might do. */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PyUnicode_CheckExact</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="c1">// 检查对象字符串的`state.interned`是否被标记</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">PyUnicode_CHECK_INTERNED</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
        <span class="k">return</span><span class="p">;</span>
        
    <span class="c1">// 初始化intern字典</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">interned</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">interned</span> <span class="o">=</span> <span class="n">PyDict_New</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">interned</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">PyErr_Clear</span><span class="p">();</span> <span class="cm">/* Don't leave an exception */</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="n">Py_ALLOW_RECURSION</span>
    <span class="cm">/* PyObject* PyDict_SetDefault(PyObject *p,PyObject *key,PyObject *defaultobj) 
       it returns the value corresponding to key from the dictionary p.
       If the key is not in the dict, it is inserted with value defaultobj and        defaultobj is returned. 
       This function evaluates the hash function of key only once, instead of evaluating it independently for the lookup and the insertion.
       */</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">PyDict_SetDefault</span><span class="p">(</span><span class="n">interned</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
    <span class="n">Py_END_ALLOW_RECURSION</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">PyErr_Clear</span><span class="p">();</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">!=</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
        <span class="n">Py_SETREF</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* The two references in interned are not counted by refcnt.
The deallocator will take care of this */</span>
    <span class="n">Py_REFCNT</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">_PyUnicode_STATE</span><span class="p">(</span><span class="n">s</span><span class="p">).</span><span class="n">interned</span> <span class="o">=</span> <span class="n">SSTATE_INTERNED_MORTAL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>由<code class="language-plaintext highlighter-rouge">interned = PyDict_New()</code>可知<code class="language-plaintext highlighter-rouge">intern</code>实际上是一个字典结构，<strong>该字典的<code class="language-plaintext highlighter-rouge">key</code>和<code class="language-plaintext highlighter-rouge">value</code>都是该字符串对象的指针。</strong>
<code class="language-plaintext highlighter-rouge">t = PyDict_SetDefault(interned, s, s)</code>是检查当前<code class="language-plaintext highlighter-rouge">intern</code>字典中是否已存在相同值的对象，存在则返回字典<code class="language-plaintext highlighter-rouge">value</code>，否则为字典添加新的一项并返回该项值。</p>

<p><img src="/img/string_object_4.png" alt="avator" /></p>

<p><code class="language-plaintext highlighter-rouge">t != s</code>表明<code class="language-plaintext highlighter-rouge">intern</code>中已存在该对象，<code class="language-plaintext highlighter-rouge">Py_INCREF(t)</code>表明增加该对象的引用计数，<code class="language-plaintext highlighter-rouge">Py_SETREF(*p, t)</code>将当前指针指向<code class="language-plaintext highlighter-rouge">intern</code>中对象，<strong><code class="language-plaintext highlighter-rouge">p</code>原来指向的字符串对象就会因为引用计数为零而被回收。这表明实际上python仍旧是先创建了一个<code class="language-plaintext highlighter-rouge">PyUnicodeObject</code>对象，然后在<code class="language-plaintext highlighter-rouge">intern</code>中检查，若已存在，则将<code class="language-plaintext highlighter-rouge">intern</code>字典中保存的<code class="language-plaintext highlighter-rouge">value</code>返回，临时创建的字符串对象因为引用计数为零而被回收。</strong>
<code class="language-plaintext highlighter-rouge">Py_REFCNT(s) -= 2</code>运行到此处时，表明已经为字典新添加了一项，<strong>因为字典的<code class="language-plaintext highlighter-rouge">key</code>和<code class="language-plaintext highlighter-rouge">value</code>值都是对象指针，因此字典会对该字符串对象的引用计数做两次加一操作</strong>，但是如果将<code class="language-plaintext highlighter-rouge">intern</code>字典的指针引用视作有效引用，那么删除该字符串对象是不可能的，因此需要将对象的引用计数减二。</p>

<p><code class="language-plaintext highlighter-rouge">_PyUnicode_STATE(s).interned = SSTATE_INTERNED_MORTAL;</code>是将字符串的<code class="language-plaintext highlighter-rouge">state.interned</code>标记为<code class="language-plaintext highlighter-rouge">SSTATE_INTERNED_MORTAL</code>，表示该对象被<code class="language-plaintext highlighter-rouge">intern</code>机制处理，但是会根据引用计数被回收。</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// include/unicodeobject.h</span>
<span class="cp">#define SSTATE_NOT_INTERNED 0  //未共享
#define SSTATE_INTERNED_MORTAL 1  // 共享，但不增加引用计数
#define SSTATE_INTERNED_IMMORTAL 2  // 共享，不被销毁
</span>
<span class="k">typedef</span>  <span class="k">struct</span> <span class="p">{</span>
<span class="p">.....</span>
    <span class="k">struct</span> <span class="p">{</span>
    <span class="p">......</span>
    <span class="kt">unsigned</span>  <span class="kt">int</span> <span class="n">interned</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
    <span class="p">......</span>
    <span class="p">}</span><span class="n">state</span>
    <span class="kt">wchar_t</span> <span class="o">*</span><span class="n">wstr</span><span class="p">;</span>
<span class="p">}</span><span class="n">PyASCIIObject</span><span class="p">;</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">PyUnicodeObject</code>内部是包含<code class="language-plaintext highlighter-rouge">PyASCLLObject</code>的，因此<code class="language-plaintext highlighter-rouge">str</code>中包含<code class="language-plaintext highlighter-rouge">intern</code>属性来表示是否采用<code class="language-plaintext highlighter-rouge">intern</code>机制。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">=</span> <span class="sh">'</span><span class="s">123</span><span class="sh">'</span>  
<span class="n">b</span> <span class="o">=</span> <span class="sh">'</span><span class="s">123</span><span class="sh">'</span>  
  
<span class="n">aa</span> <span class="o">=</span> <span class="sh">'</span><span class="s">1 23</span><span class="sh">'</span>  
<span class="n">bb</span> <span class="o">=</span> <span class="sh">'</span><span class="s">1 23</span><span class="sh">'</span>  
  
<span class="nf">print</span><span class="p">(</span><span class="nf">id</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>  
<span class="nf">print</span><span class="p">(</span><span class="nf">id</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>  
<span class="nf">print</span><span class="p">(</span><span class="nf">id</span><span class="p">(</span><span class="n">aa</span><span class="p">))</span>  
<span class="nf">print</span><span class="p">(</span><span class="nf">id</span><span class="p">(</span><span class="n">bb</span><span class="p">))</span>  


<span class="o">//</span> <span class="n">使用IDE直接运行的结果</span>
<span class="mi">2565521000968</span>
<span class="mi">2565521000968</span>
<span class="mi">2565521000800</span>
<span class="mi">2565521000800</span>

<span class="o">//</span> <span class="n">使用控制台的结果</span>
<span class="mi">2666168414256</span>
<span class="mi">2666168414256</span>
<span class="mi">2666166545800</span>
<span class="mi">2666167772024</span>
</code></pre></div></div>
<p>上述代码中主要存在两点疑问，一是为什么使用不同的运行方式结果会不同？二是字符串看起来有时候存在<code class="language-plaintext highlighter-rouge">intern</code>机制，有时候又不存在，其限制条件是什么？</p>

<p>首先，需要明白为什么两种运行方式结果不同。这里我们需要明白的是使用IDE运行，实际上是<strong>将当前<code class="language-plaintext highlighter-rouge">.py</code>文件作为一个模块的，这一个模块是属于同一个代码块的，而python对每个代码块都会提供一个常量池，常量池中共享对象。而控制台中代码行运行，每一行代码都会视作一个代码块。</strong>（可以验证之前的大整数对象，当你赋值两个相同值的大整数，两种运行方式结果是不同的，因为常量池是针对代码块的）</p>

<p><strong><code class="language-plaintext highlighter-rouge">intern</code>限制条件</strong></p>

<p>正如共享对象中的种种限制，不可能所有的字符串我们都默认使用<code class="language-plaintext highlighter-rouge">intern</code>机制，实际上只有满足一定条件的字符串才会使用。
具体约束条件如下：
1.字符串必须是编译时常量 – 任何在运行时才被构建的字符串是不会使用<code class="language-plaintext highlighter-rouge">intern</code>机制的。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">=</span> <span class="sh">"</span><span class="s">Holberton</span><span class="sh">"</span>  
<span class="n">b</span> <span class="o">=</span> <span class="sh">"</span><span class="s">Holb</span><span class="sh">"</span> <span class="o">+</span> <span class="sh">"</span><span class="s">erton</span><span class="sh">"</span>  
<span class="nf">print</span><span class="p">(</span><span class="n">a</span> <span class="ow">is</span> <span class="n">b</span><span class="p">)</span>

<span class="bp">True</span>

<span class="n">a</span> <span class="o">=</span> <span class="sh">"</span><span class="s">Holberton</span><span class="sh">"</span>  
<span class="n">b</span> <span class="o">=</span> <span class="sh">""</span><span class="p">.</span><span class="nf">join</span><span class="p">([</span><span class="sh">"</span><span class="s">H</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">o</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">l</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">b</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">e</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">r</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">t</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">o</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">n</span><span class="sh">"</span><span class="p">])</span>  
<span class="nf">print</span><span class="p">(</span><span class="n">a</span> <span class="ow">is</span> <span class="n">b</span><span class="p">)</span>

<span class="bp">False</span>
</code></pre></div></div>
<p>2.字符串超过20时，不能是以常量字符串合并的方式。</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">=</span> <span class="sh">'</span><span class="s">123456789123456789123456789</span><span class="sh">'</span>  
<span class="n">b</span> <span class="o">=</span> <span class="sh">'</span><span class="s">123456789123456789123456789</span><span class="sh">'</span>  
<span class="nf">print</span><span class="p">(</span><span class="n">a</span> <span class="ow">is</span> <span class="n">b</span><span class="p">)</span>

<span class="bp">True</span>

<span class="n">a</span> <span class="o">=</span> <span class="sh">'</span><span class="s">123456789</span><span class="sh">'</span><span class="o">+</span><span class="sh">'</span><span class="s">123456789123456789</span><span class="sh">'</span>  
<span class="n">b</span> <span class="o">=</span> <span class="sh">'</span><span class="s">123456789</span><span class="sh">'</span><span class="o">+</span><span class="sh">'</span><span class="s">123456789123456789</span><span class="sh">'</span>  
<span class="nf">print</span><span class="p">(</span><span class="n">a</span> <span class="ow">is</span> <span class="n">b</span><span class="p">)</span>

<span class="bp">False</span>
</code></pre></div></div>
<p>3.字符串只能包含ASCLL字母，数字以及下划线。（验证时，注意要使得两字符串在不同的代码块中）</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">=</span> <span class="sh">'</span><span class="s">a!</span><span class="sh">'</span>  
<span class="n">b</span> <span class="o">=</span> <span class="sh">'</span><span class="s">a!</span><span class="sh">'</span>  
<span class="nf">print</span><span class="p">(</span><span class="n">a</span> <span class="ow">is</span> <span class="n">b</span><span class="p">)</span>

<span class="o">//</span><span class="n">控制台</span>
<span class="n">Fasle</span>


<span class="n">a</span> <span class="o">=</span> <span class="sh">'</span><span class="s">a</span><span class="sh">'</span>  
<span class="nf">print</span><span class="p">(</span><span class="nf">id</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>  
<span class="k">def</span> <span class="nf">test</span><span class="p">():</span>  
    <span class="n">b</span> <span class="o">=</span> <span class="sh">'</span><span class="s">a</span><span class="sh">'</span>  
  <span class="nf">print</span><span class="p">(</span><span class="nf">id</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>  
<span class="nf">test</span><span class="p">()</span>

<span class="mi">2200424256600</span>
<span class="mi">2200424256600</span>
 
<span class="k">def</span> <span class="nf">test</span><span class="p">():</span>  
    <span class="n">b</span> <span class="o">=</span> <span class="sh">'</span><span class="s">a!</span><span class="sh">'</span>  
    <span class="nf">print</span><span class="p">(</span><span class="nf">id</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>  
<span class="n">a</span> <span class="o">=</span> <span class="sh">'</span><span class="s">a!</span><span class="sh">'</span>  
<span class="nf">print</span><span class="p">(</span><span class="nf">id</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> 
<span class="nf">test</span><span class="p">()</span>

<span class="mi">2278949243232</span>
<span class="mi">2278949243400</span>
</code></pre></div></div>
<p>另外空串<code class="language-plaintext highlighter-rouge">''</code>是经过<code class="language-plaintext highlighter-rouge">intern</code>机制的。
<img src="/img/string_object_5.png" alt="avator" /></p>
